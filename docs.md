## Comparación entre Git Flow y Trunk-based development

Durante el desarrollo del proyecto URL‑Shortener, el equipo se enfrentó al reto de aplicar dos enfoques de ramificación con características diferentes. Por un lado, **Git Flow**, por otro, **Trunk‑Based Development (TBD).** El propósito de este documento es plasmar nuestra experiencia comparando las ventajas, desventajas y el contexto que consideramos ideal de cada enfoque. 

Comenzamos el proyecto aplicando Git Flow a partir de la guía de desarrollo para el proyecto “Workflows avanzados de Git: Git flow y trunk-based development local”. Configuramos la rama de producción main, creamos una rama de desarrollo develop y, casi exclusivamente, creamos a partir de ella ramas feature para cada nueva funcionalidad. Cuando alcanzamos el propósito funcional de la rama, esta es cerrada y consolidamos el resultado haciendo merge a develop.

Durante el desarrollo, Git Flow nos permitió mantener un entorno estable para la versión candidata mientras cada miembro del equipo trabajaba en características separadas (algunas no tan aisladas). La organización que provee se hizo resaltar cuando hubo un renombramiento en nuestras variables de entorno. ¿Por qué es de relevancia? Porque, a diferencia de TBD, las características o cambios por ser implementados que señalan cambios en lugares donde no se había realizado modificaciones (i.e. URL_DB) no rompían la producción principal, dado que sí afectaron a nuestro archivo app.py. En TBD, estos problemas generan retrasos y rupturas en producción que, para que no llegasen a suceder, requirieron de una revisión grupal de algunos pull-request.

La comparación directa revela elementos contrapuestos. Git Flow ofrece una sensación de orden y una línea temporal clara para los releases, algo valioso cuando como desarrolladores trabajamos para cumplir con entregas y podemos entregar versiones etiquetadas y documentadas. Además facilita la convivencia de varios entornos, por ejemplo, un servidor de pruebas que siga el estado de la rama release mientras producción permanece estable en main. En cambio, Trunk‑Based Development, en contraste, simplifica la topología de las versiones de los commits en su única rama de larga vida elimina la confusión sobre dónde vive el código “real”. El conflicto es cultural y técnico, pues se requiere disciplina para fraccionar user stories en porciones muy pequeñas y herramientas de automatización que validen cada commit casi en tiempo real.

Durante los sprints observamos que ninguno de los dos modelos queda libre de errores, pero su forma de exponerlos difiere. Con Git Flow los fallos suelen aparecer al final, cuando se fusionan varios commits de trabajo, con un impacto grande pero con poca frecuencia. Con Trunk‑Based las equivocaciones aparecen rápido, a menudo al instante de una integración, pero su radio de efecto es pequeño porque el cambio todavía es manejable. Elegir entre uno y otro depende entonces de la tolerancia al riesgo, de la frecuencia de despliegue deseada y de la infraestructura de pruebas disponible.



| Workflow                          | Ventajas                                                     | Desventajas                                                  |
| --------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **Git Flow**                      | - Estructura clara: separación de `main`, `develop`, `feature`, `release` y `hotfix`.<br>- Entornos paralelos: staging en `release` y producción en `main`.<br>- Gestión de topología de las versiones: bifurcaciones visibles en `git log --graph --oneline`. | - Complejidad operativa: merges frecuentes y conflictos acumulados.<br>- Ciclo de entrega más lento: integración centralizada en `develop`.<br>- Feedback tardío: errores detectados al final del ciclo. |
| **Trunk-Based Development (TBD)** | - Sencillez de la historia: una sola rama de larga vida; topología de los commits (visualizable con `git log --graph --oneline`) lineal y fácil de entender.<br>- Feedback inmediato: pipelines de CI por commit.<br>- Entrega continua: microdeploys frecuentes y reducción del time-to-market. | - Disciplina exigente: fragmentación de historias de usuario en cambios muy pequeños.<br>- Riesgo de inestabilidad: un commit roto puede interrumpir CD.<br>- Dependencia de infraestructura automatizada: tests de alta cobertura y despliegues ágiles. |

De acuerdo a esta experiencia, Git Flow resulta más adecuado en productos cuyo desarrollo implica entregas de forma mensual o trimestral, en especial si existen requisitos regulatorios o la necesidad de mantener varias versiones activas. Trunk‑Based, por otra parte, resulta más efectivo en microservicios desplegados de manera continua, donde la prioridad es entregar valor al usuario tantas veces como sea posible y donde la organización cuenta con pruebas automáticas extensas, integración continua rápida y la cultura DevOps está madura.

Finalmente, concluimos que no existe un modelo universal ideal para todo objetivo o equipo de desarrollo, sino que cada equipo debe evaluar su nivel de madurez, necesidades de entrega y velocidad de entrega para elegir el flujo de trabajo que mejor se adapte a sus objetivos.
